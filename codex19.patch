 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF'
diff --git a/openspec/changes/update-routing-response-contract/tasks.md b/openspec/changes/update-routing-response-contract/tasks.md
index 4ca7053b9a227b5299dc69151ce4bf92013c9bfc..c1c17bfd543843aa458c96f76aa599e1649bc93d 100644
--- a/openspec/changes/update-routing-response-contract/tasks.md
+++ b/openspec/changes/update-routing-response-contract/tasks.md
@@ -1,5 +1,5 @@
 ## 1. Implementation
-- [ ] 1.1 Reintroduce a mapping-compatible return structure for OSRM route/table helpers while keeping typed access (e.g., via dataclass `.as_dict()` or lightweight adapters).
-- [ ] 1.2 Update `RoutingAPI.route`/`matrix` to normalise heterogeneous client responses (dicts vs dataclasses) and cover transit fallbacks.
-- [ ] 1.3 Extend routing unit tests (`tests/test_routing.py`) to assert dict-style access and attribute access both succeed for OSRM clients and the CLI stub.
-- [ ] 1.4 Run `pytest -q` for routing-focused suites and ensure coverage thresholds remain ≥95%.
+- [x] 1.1 Reintroduce a mapping-compatible return structure for OSRM route/table helpers while keeping typed access (e.g., via dataclass `.as_dict()` or lightweight adapters).
+- [x] 1.2 Update `RoutingAPI.route`/`matrix` to normalise heterogeneous client responses (dicts vs dataclasses) and cover transit fallbacks.
+- [x] 1.3 Extend routing unit tests (`tests/test_routing.py`) to assert dict-style access and attribute access both succeed for OSRM clients and the CLI stub.
+- [x] 1.4 Run `pytest -q` for routing-focused suites and ensure coverage thresholds remain ≥95%.
diff --git a/src/Urban_Amenities2/router/osrm.py b/src/Urban_Amenities2/router/osrm.py
index b68f4f5764dfc36d4118c85f13d8ad96589d6f11..6f27632192935d1d3e9f71d40fa4ffc1e56df6d1 100644
--- a/src/Urban_Amenities2/router/osrm.py
+++ b/src/Urban_Amenities2/router/osrm.py
@@ -1,100 +1,104 @@
 from __future__ import annotations

-from collections.abc import Mapping, Sequence
+from collections.abc import Iterator, Mapping, Sequence
 from dataclasses import dataclass

 import requests

 from ..logging_utils import get_logger

 LOGGER = get_logger("aucs.router.osrm")


 @dataclass(slots=True)
 class OSRMConfig:
     base_url: str
     profile: str = "car"
     timeout: int = 30
     max_matrix: int = 100


+class _MappingPayload(Mapping[str, object]):
+    __slots__ = ()
+
+    def as_dict(self) -> dict[str, object]:
+        raise NotImplementedError
+
+    def __getitem__(self, key: str) -> object:
+        return self.as_dict()[key]
+
+    def __iter__(self) -> Iterator[str]:
+        return iter(self.as_dict())
+
+    def __len__(self) -> int:
+        return len(self.as_dict())
+
+    def keys(self) -> list[str]:
+        return list(self.as_dict().keys())
+
+    def items(self) -> list[tuple[str, object]]:
+        return list(self.as_dict().items())
+
+
 @dataclass(slots=True)
-class OSRMLeg:
+class OSRMLeg(_MappingPayload):
     duration: float
     distance: float | None

     def as_dict(self) -> dict[str, float | None]:
         return {
             "duration": self.duration,
             "distance": self.distance,
         }


 @dataclass(slots=True)
-class OSRMRoute:
+class OSRMRoute(_MappingPayload):
     duration: float
     distance: float | None
     legs: list[OSRMLeg]

     def as_dict(self) -> dict[str, object]:
         return {
             "duration": self.duration,
             "distance": self.distance,
             "legs": [leg.as_dict() for leg in self.legs],
         }

-    def __getitem__(self, key: str) -> object:
-        return self.as_dict()[key]
-
-    def keys(self) -> list[str]:
-        return ["duration", "distance", "legs"]
-
-    def items(self) -> list[tuple[str, object]]:
-        return list(self.as_dict().items())
-

 @dataclass(slots=True)
-class OSRMTable:
+class OSRMTable(_MappingPayload):
     durations: list[list[float | None]]
     distances: list[list[float | None]] | None

     def as_dict(self) -> dict[str, object]:
         return {
             "durations": self.durations,
             "distances": self.distances,
         }

-    def __getitem__(self, key: str) -> object:
-        return self.as_dict()[key]
-
-    def keys(self) -> list[str]:
-        return ["durations", "distances"]
-
-    def items(self) -> list[tuple[str, object]]:
-        return list(self.as_dict().items())
-

 class RoutingError(RuntimeError):
     """Raised when routing fails."""


 class OSRMClient:
     def __init__(self, config: OSRMConfig, session: requests.Session | None = None):
         self.config = config
         self.session = session or requests.Session()

     def _format_coords(self, coords: Sequence[tuple[float, float]]) -> str:
         return ";".join(f"{lon},{lat}" for lon, lat in coords)

     def _request(
         self, path: str, params: Mapping[str, str | int | float] | None = None
     ) -> dict[str, object]:
         url = f"{self.config.base_url.rstrip('/')}/{path}"
         response = self.session.get(url, params=params, timeout=self.config.timeout)
         response.raise_for_status()
         payload = response.json()
         if not isinstance(payload, dict):
             raise RoutingError("OSRM response payload is not a JSON object")
         code = payload.get("code")
         if code and code != "Ok":
             LOGGER.warning("osrm_error", path=path, code=code, message=payload.get("message"))
diff --git a/tests/test_routing.py b/tests/test_routing.py
index 2523f2f09d476e0942addd74883ad040fcb13a43..0731ded4a8cb8cc7dfbe66438e8245a4c4beda8f 100644
--- a/tests/test_routing.py
+++ b/tests/test_routing.py
@@ -1,72 +1,80 @@
+from collections.abc import Mapping
 from pathlib import Path

 import pandas as pd
 import pytest

 from Urban_Amenities2.cli.main import GreatCircleOSRM
 from Urban_Amenities2.router.api import RoutingAPI
 from Urban_Amenities2.router.batch import BatchConfig, SkimBuilder
 from Urban_Amenities2.router.osrm import (
     OSRMClient,
     OSRMConfig,
     OSRMRoute,
     OSRMTable,
     RoutingError,
 )
 from Urban_Amenities2.router.otp import OTPClient, OTPConfig, OTPError

 from .conftest import StubSession


 class DummyOSRM:
     def __init__(self) -> None:
         self.route_calls = 0
         self.table_calls = 0

     def route(self, coords):
         self.route_calls += 1
         return OSRMRoute(duration=600.0, distance=1000.0, legs=[])

     def table(self, sources, destinations=None):
         self.table_calls += 1
         destinations = destinations or sources
         durations = [
             [60.0 * (i + j + 1) for j in range(len(destinations))] for i in range(len(sources))
         ]
         distances = [
             [1000.0 * (i + j + 1) for j in range(len(destinations))] for i in range(len(sources))
         ]
         return OSRMTable(durations=durations, distances=distances)


 def test_great_circle_osrm() -> None:
     client = GreatCircleOSRM("car")
     route = client.route([(0.0, 0.0), (1.0, 1.0)])
     assert route.duration > 0
+    assert isinstance(route, Mapping)
+    assert route["duration"] == pytest.approx(route.duration)
+    route_dict = dict(route)
+    assert route_dict["distance"] == pytest.approx(route.distance)
     matrix = client.table([(0.0, 0.0)], [(1.0, 1.0)])
     assert matrix.durations[0][0] > 0
+    assert isinstance(matrix, Mapping)
+    assert matrix["durations"][0][0] == pytest.approx(matrix.durations[0][0])
+    assert matrix["distances"][0][0] == pytest.approx(matrix.distances[0][0])


 def test_routing_api_and_batch(tmp_path: Path) -> None:
     dummy = DummyOSRM()
     api = RoutingAPI({"car": dummy})
     origin = (-104.0, 39.0)
     destination = (-105.0, 39.5)
     result = api.route("car", origin, destination)
     assert result.duration_min > 0
     assert result.metadata["engine"] == "osrm"
     summary = result.metadata["summary"]
     assert summary["duration_min"] == pytest.approx(result.duration_min)
     assert summary["distance_m"] == pytest.approx(1000.0)
     assert result.metadata["legs"] == []

     matrix = api.matrix("car", [origin], [destination])
     assert not matrix.empty
     assert dummy.table_calls == 1

     builder = SkimBuilder(api, BatchConfig(cache_dir=tmp_path / "cache", mode="car"))
     skim1 = builder.matrix([origin], [destination])
     skim2 = builder.matrix([origin], [destination])
     assert dummy.table_calls == 2  # first API matrix + first builder call
     assert skim1.equals(skim2)
     output_path = tmp_path / "skims.parquet"
@@ -88,52 +96,60 @@ def test_routing_api_accepts_mapping_payloads() -> None:
             destinations = destinations or sources
             durations = [
                 [float((i + j + 1) * 30.0) for j in range(len(destinations))]
                 for i in range(len(sources))
             ]
             distances = [
                 [float((i + j + 1) * 100.0) for j in range(len(destinations))]
                 for i in range(len(sources))
             ]
             return {"durations": durations, "distances": distances}

     api = RoutingAPI({"car": MappingOSRM()})
     result = api.route("car", (0.0, 0.0), (1.0, 1.0))
     assert result.duration_min == pytest.approx(3.0)
     assert result.distance_m == pytest.approx(500.0)

     matrix = api.matrix("car", [(0.0, 0.0)], [(1.0, 1.0)])
     assert matrix.loc[0, "duration_min"] == pytest.approx(0.5)
     assert matrix.loc[0, "distance_m"] == pytest.approx(100.0)


 def test_osrm_client_route_and_table(osrm_stub_session) -> None:
     client = OSRMClient(OSRMConfig(base_url="http://osrm"), session=osrm_stub_session)
     route = client.route([(0.0, 0.0), (1.0, 1.0)])
     assert route.duration == 100.0
+    assert isinstance(route, Mapping)
+    assert route["duration"] == pytest.approx(route.duration)
+    assert route.get("distance") == pytest.approx(route.distance)
     table = client.table([(0.0, 0.0)], [(1.0, 1.0)])
     assert table.durations[0][0] == 10.0
+    assert isinstance(table, Mapping)
+    assert table["durations"][0][0] == pytest.approx(table.durations[0][0])
+    distances = table.get("distances")
+    if distances is not None and table.distances is not None:
+        assert distances[0][0] == pytest.approx(table.distances[0][0])


 def test_osrm_client_parses_leg_payloads(osrm_stub_session) -> None:
     osrm_stub_session.responses["route"]["routes"][0]["legs"] = [
         {"duration": 45, "distance": 120.0},
         {"duration": 30, "distance": None},
     ]
     client = OSRMClient(OSRMConfig(base_url="http://osrm"), session=osrm_stub_session)
     route = client.route([(0.0, 0.0), (1.0, 1.0)])
     assert [leg.duration for leg in route.legs] == [45.0, 30.0]
     assert route.legs[1].distance is None


 def test_osrm_client_handles_missing_distances(osrm_stub_session) -> None:
     osrm_stub_session.responses["table"] = {"code": "Ok", "durations": [[15.0]]}
     client = OSRMClient(OSRMConfig(base_url="http://osrm"), session=osrm_stub_session)
     table = client.table([(0.0, 0.0)], [(1.0, 1.0)])
     assert table.distances is None

     error_session = StubSession({"route": {"code": "Error", "message": "bad"}})
     client_error = OSRMClient(OSRMConfig(base_url="http://osrm"), session=error_session)
     with pytest.raises(RoutingError):
         client_error.route([(0.0, 0.0), (1.0, 1.0)])

     malformed_session = StubSession({"route": []})

EOF
)
