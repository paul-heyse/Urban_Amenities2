diff a/src/Urban_Amenities2/ui/hex_selection.py b/src/Urban_Amenities2/ui/hex_selection.py	(rejected hunks)
@@ -1,95 +1,97 @@
 """Hex selection and detail viewing."""

 from __future__ import annotations

-from dataclasses import dataclass
+from dataclasses import dataclass, field
+from importlib import import_module
+from typing import Sequence, cast

 import pandas as pd
 import structlog

 logger = structlog.get_logger()


 @dataclass
 class HexDetails:
     """Detailed information for a selected hex."""

     hex_id: str
     lat: float
     lon: float
     state: str
     metro: str | None
     county: str | None
     population: float | None
     aucs: float
     ea: float
     lca: float
     muhaa: float
     jea: float
     morr: float
     cte: float
     sou: float
-    top_amenities: list[dict[str, str]] = None
-    top_modes: dict[str, float] = None
+    top_amenities: list[dict[str, str]] = field(default_factory=list)
+    top_modes: dict[str, float] = field(default_factory=dict)

     @classmethod
     def from_row(cls, row: pd.Series) -> HexDetails:
         """
         Create HexDetails from a DataFrame row.

         Args:
             row: DataFrame row with hex data

         Returns:
             HexDetails instance
         """
         return cls(
             hex_id=row["hex_id"],
             lat=row["lat"],
             lon=row["lon"],
             state=row["state"],
             metro=row.get("metro"),
             county=row.get("county"),
             population=row.get("population"),
             aucs=row["aucs"],
             ea=row["ea"],
             lca=row["lca"],
             muhaa=row["muhaa"],
             jea=row["jea"],
             morr=row["morr"],
             cte=row["cte"],
             sou=row["sou"],
             top_amenities=row.get("top_amenities", []),
             top_modes=row.get("top_modes", {}),
         )


 class HexSelector:
     """Manage hex selection and comparison."""

-    def __init__(self, df: pd.DataFrame):
+    def __init__(self, df: pd.DataFrame) -> None:
         """
         Initialize hex selector.

         Args:
             df: DataFrame with hex-level scores
         """
         self.df = df
         self.selected_hexes: list[str] = []
         self.max_selection = 5

     def select_hex(self, hex_id: str) -> bool:
         """
         Select a hex for viewing details.

         Args:
             hex_id: Hex ID to select

         Returns:
             True if selection succeeded, False if limit reached
         """
         if hex_id in self.selected_hexes:
             logger.info("hex_already_selected", hex_id=hex_id)
             return True

         if len(self.selected_hexes) >= self.max_selection:
@@ -134,35 +136,33 @@ class HexSelector:
         return HexDetails.from_row(row.iloc[0])

     def get_comparison_data(self) -> pd.DataFrame:
         """
         Get comparison data for all selected hexes.

         Returns:
             DataFrame with selected hexes and their scores
         """
         if not self.selected_hexes:
             return pd.DataFrame()

         return self.df[self.df["hex_id"].isin(self.selected_hexes)].copy()

     def get_neighbors(self, hex_id: str, k: int = 6) -> pd.DataFrame:
         """
         Get neighboring hexes (by H3 ring).

         Args:
             hex_id: Center hex ID
             k: Number of rings (default 1 ring = 6 neighbors)

         Returns:
             DataFrame with neighboring hexes
         """
-        import h3
-
-        # Get neighbor hex IDs
-        neighbor_ids = list(h3.k_ring(hex_id, k=1))
+        h3 = import_module("h3")
+        neighbor_ids = cast(Sequence[str], h3.k_ring(hex_id, k=k))

         # Filter to neighbors in dataset
         neighbors = self.df[self.df["hex_id"].isin(neighbor_ids)].copy()

         return neighbors

