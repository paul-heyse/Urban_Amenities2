diff a/src/Urban_Amenities2/ui/filters.py b/src/Urban_Amenities2/ui/filters.py	(rejected hunks)
@@ -1,82 +1,91 @@
 """Advanced filtering capabilities for the AUCS UI."""

 from __future__ import annotations

 from dataclasses import dataclass
-from typing import Any

 import pandas as pd

+from .types import FilterOptions

-@dataclass
+
+@dataclass(slots=True)
 class FilterConfig:
     """Configuration for data filters."""

     state: list[str] | None = None
     metro: list[str] | None = None
+    county: list[str] | None = None
     score_min: float | None = None
     score_max: float | None = None
     population_density_min: float | None = None
     population_density_max: float | None = None
     land_use: list[str] | None = None


 def apply_filters(df: pd.DataFrame, config: FilterConfig) -> pd.DataFrame:
     """
     Apply filters to the dataset.

     Args:
         df: DataFrame with hex-level scores
         config: Filter configuration

     Returns:
         Filtered DataFrame
     """
     filtered = df.copy()

     if config.state is not None:
         filtered = filtered[filtered["state"].isin(config.state)]

     if config.metro is not None:
         filtered = filtered[filtered["metro"].isin(config.metro)]

+    if config.county is not None:
+        filtered = filtered[filtered["county"].isin(config.county)]
+
     if config.score_min is not None:
         filtered = filtered[filtered["aucs"] >= config.score_min]

     if config.score_max is not None:
         filtered = filtered[filtered["aucs"] <= config.score_max]

     if config.population_density_min is not None:
         filtered = filtered[filtered["pop_density"] >= config.population_density_min]

     if config.population_density_max is not None:
         filtered = filtered[filtered["pop_density"] <= config.population_density_max]

     if config.land_use is not None:
         filtered = filtered[filtered["land_use"].isin(config.land_use)]

     return filtered


-def get_filter_options(df: pd.DataFrame) -> dict[str, Any]:
+def get_filter_options(df: pd.DataFrame) -> FilterOptions:
     """
     Extract available filter options from the dataset.

     Args:
         df: DataFrame with hex-level scores

     Returns:
         Dictionary with available filter values
     """
+    min_score = float(df["aucs"].min()) if not df.empty else 0.0
+    max_score = float(df["aucs"].max()) if not df.empty else 0.0
+    if "pop_density" in df.columns and not df["pop_density"].empty:
+        density_min = float(df["pop_density"].min())
+        density_max = float(df["pop_density"].max())
+    else:
+        density_min = density_max = 0.0
     return {
-        "states": sorted(df["state"].unique().tolist()),
-        "metros": sorted(df["metro"].unique().tolist()),
-        "score_range": [float(df["aucs"].min()), float(df["aucs"].max())],
-        "land_uses": sorted(df["land_use"].unique().tolist()) if "land_use" in df.columns else [],
-        "population_density_range": (
-            [float(df["pop_density"].min()), float(df["pop_density"].max())]
-            if "pop_density" in df.columns
-            else [0, 0]
-        ),
+        "states": sorted(df["state"].dropna().astype(str).unique().tolist()) if "state" in df.columns else [],
+        "metros": sorted(df["metro"].dropna().astype(str).unique().tolist()) if "metro" in df.columns else [],
+        "counties": sorted(df["county"].dropna().astype(str).unique().tolist()) if "county" in df.columns else [],
+        "score_range": (min_score, max_score),
+        "land_uses": sorted(df["land_use"].dropna().astype(str).unique().tolist()) if "land_use" in df.columns else [],
+        "population_density_range": (density_min, density_max),
     }

